<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Solver - Backtracking Algorithm</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: #f4f4f4; 
            margin: 0; 
            padding: 10px; 
            height: 100vh;
            overflow: hidden;
        }
        h2 { text-align: center; color: #333; margin: 5px 0; font-size: 18px; }
        #sudoku-container { 
            display: flex; 
            justify-content: center; 
            align-items: flex-start; 
            gap: 20px; 
            margin: 10px 0; 
            height: calc(100vh - 50px);
        }
        #sudoku-grid { 
            display: grid; 
            grid-template-columns: repeat(9, 45px); 
            grid-template-rows: repeat(9, 45px); 
            gap: 2px; 
            border: 3px solid #333; 
            background: #333; 
            padding: 3px; 
        }
        .sudoku-cell { 
            width: 50px; 
            height: 50px; 
            background: #fff; 
            border: 1px solid #ccc; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 18px; 
            font-weight: bold; 
            cursor: pointer; 
            transition: all 0.3s ease;
        }
        .sudoku-cell:nth-child(3n):not(:nth-child(9n)) { border-right: 2px solid #333; }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid #333; }
        .sudoku-cell.given { background: #e3f2fd; color: #1565c0; }
        .sudoku-cell.solving { background: #ffeb3b; animation: pulse 0.5s; }
        .sudoku-cell.backtrack { background: #ffcdd2; animation: shake 0.3s; }
        .sudoku-cell.solved { background: #c8e6c9; }
        .sudoku-cell input { 
            width: 100%; 
            height: 100%; 
            border: none; 
            text-align: center; 
            font-size: 18px; 
            font-weight: bold; 
            background: transparent; 
        }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        #controls { 
            display: flex; 
            flex-direction: column; 
            gap: 5px; 
            min-width: 180px; 
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }
        button { 
            padding: 6px 10px; 
            background: #2196f3; 
            color: white; 
            border: none; 
            border-radius: 3px; 
            cursor: pointer; 
            font-size: 12px; 
            transition: all 0.2s ease;
            margin: 1px 0;
        }
        button:hover { 
            background: #1976d2; 
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        h3, h4 { 
            color: #333; 
            margin: 8px 0 3px 0; 
            font-size: 14px;
        }
        small { 
            color: #666; 
            font-style: italic; 
            font-size: 10px;
        }
        #stats { 
            background: #fff; 
            padding: 8px; 
            border-radius: 3px; 
            margin-top: 5px; 
            font-size: 12px;
        }
        #speed-control { margin: 5px 0; }
        #speed-slider { width: 100%; }
    </style>
</head>
<body>
    <h2>üß© Sudoku Solver - Backtracking Algorithm Visualizer</h2>
    <div id="sudoku-container">
        <div id="sudoku-grid"></div>
        <div id="controls">
            <!-- Puzzle Loading Controls -->
            <h3>üìã Load Puzzles</h3>
            <button onclick="loadEasyPuzzle()" title="Load an easy puzzle with more given numbers">üü¢ Easy Puzzle</button>
            <button onclick="loadMediumPuzzle()" title="Load a medium difficulty puzzle">üü° Medium Puzzle</button>
            <button onclick="loadHardPuzzle()" title="Load a challenging puzzle with fewer clues">üî¥ Hard Puzzle</button>
            <button onclick="clearGrid()" title="Clear the grid to enter your own puzzle">üóëÔ∏è Clear Grid</button>
            
            <hr>
            
            <!-- AI Solver Controls -->
            <h3>ü§ñ AI Solver</h3>
            <button id="solve-btn" onclick="solveSudoku()" title="Watch the backtracking algorithm solve step-by-step">üé¨ Solve with Animation</button>
            <button onclick="solveInstant()" title="Solve immediately without animation - shows final result instantly">‚ö° Solve Instantly</button>
            <button onclick="stopSolving()" title="Stop the current solving process">‚èπÔ∏è Stop</button>
            
            <!-- Speed Control -->
            <div id="speed-control">
                <h4>üéöÔ∏è Animation Speed</h4>
                <label>Speed: <span id="speed-value">0.1ms</span></label>
                <input type="range" id="speed-slider" min="0.1" max="5" step="0.1" value="0.1" oninput="updateSpeed(this.value)" 
                       title="0.1ms = Lightning Fast, 5ms = Slower">
                <small>üí° Lower = Faster</small>
            </div>
            
            <!-- Statistics -->
            <div id="stats">
                <h4>üìä Algorithm Statistics:</h4>
                <div title="Number of cells the algorithm attempted to fill">üî¢ Steps: <span id="steps">0</span></div>
                <div title="Times the algorithm had to undo and try different numbers">‚¨ÖÔ∏è Backtracks: <span id="backtracks">0</span></div>
                <div title="Total time taken to solve the puzzle">‚è±Ô∏è Time: <span id="time">0ms</span></div>
                <div title="Current solving status">üìç Status: <span id="status">Ready</span></div>
            </div>
            
            <!-- Instructions -->
            <div style="background: #f0f8ff; padding: 5px; border-radius: 3px; margin-top: 5px;">
                <h4>üìù Quick Guide:</h4>
                <ul style="font-size: 10px; margin: 2px 0; padding-left: 15px;">
                    <li>Click cells ‚Üí type 1-9</li>
                    <li>Animation = step-by-step</li>
                    <li>Instant = immediate result</li>
                </ul>
            </div>
        </div>
    </div>
    <script>
        let grid = Array.from({length: 9}, () => Array(9).fill(0));
        let solving = false;
        let speed = 0.1; // Ultra fast visualization - 0.1ms
        let steps = 0;
        let backtracks = 0;
        let startTime = 0;

        // Predefined puzzles
        const puzzles = {
            easy: [
                [5,3,0,0,7,0,0,0,0],
                [6,0,0,1,9,5,0,0,0],
                [0,9,8,0,0,0,0,6,0],
                [8,0,0,0,6,0,0,0,3],
                [4,0,0,8,0,3,0,0,1],
                [7,0,0,0,2,0,0,0,6],
                [0,6,0,0,0,0,2,8,0],
                [0,0,0,4,1,9,0,0,5],
                [0,0,0,0,8,0,0,7,9]
            ],
            medium: [
                [0,0,0,6,0,0,4,0,0],
                [7,0,0,0,0,3,6,0,0],
                [0,0,0,0,9,1,0,8,0],
                [0,0,0,0,0,0,0,0,0],
                [0,5,0,1,8,0,0,0,3],
                [0,0,0,3,0,6,0,4,5],
                [0,4,0,2,0,0,0,6,0],
                [9,0,3,0,0,0,0,0,0],
                [0,2,0,0,0,0,1,0,0]
            ],
            hard: [
                [0,0,0,0,0,0,6,8,0],
                [0,0,0,0,4,6,0,0,0],
                [7,0,0,0,0,0,0,0,9],
                [0,5,0,0,0,0,0,0,0],
                [0,0,0,1,0,6,0,0,0],
                [3,0,0,0,0,0,0,0,0],
                [0,4,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0],
                [0,0,5,2,0,0,3,0,0]
            ]
        };

        function initGrid() {
            const gridElement = document.getElementById('sudoku-grid');
            gridElement.innerHTML = '';
            
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'sudoku-cell';
                cell.id = `cell-${Math.floor(i/9)}-${i%9}`;
                
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '1';
                input.max = '9';
                input.onchange = (e) => updateCell(Math.floor(i/9), i%9, e.target.value);
                
                cell.appendChild(input);
                gridElement.appendChild(cell);
            }
        }

        function updateCell(row, col, value) {
            grid[row][col] = value ? parseInt(value) : 0;
        }

        function displayGrid() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    const input = cell.querySelector('input');
                    input.value = grid[r][c] || '';
                }
            }
        }

        function loadPuzzle(difficulty) {
            grid = puzzles[difficulty].map(row => [...row]);
            displayGrid();
            markGivenCells();
            resetStats();
        }

        function loadEasyPuzzle() { loadPuzzle('easy'); }
        function loadMediumPuzzle() { loadPuzzle('medium'); }
        function loadHardPuzzle() { loadPuzzle('hard'); }

        function clearGrid() {
            grid = Array.from({length: 9}, () => Array(9).fill(0));
            displayGrid();
            clearVisualEffects();
            resetStats();
        }

        function markGivenCells() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    if (grid[r][c] !== 0) {
                        cell.classList.add('given');
                        cell.querySelector('input').disabled = true;
                    } else {
                        cell.classList.remove('given');
                        cell.querySelector('input').disabled = false;
                    }
                }
            }
        }

        function clearVisualEffects() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    cell.classList.remove('solving', 'backtrack', 'solved');
                }
            }
        }

        function isValid(grid, row, col, num) {
            // Check row
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num) return false;
            }
            
            // Check column
            for (let x = 0; x < 9; x++) {
                if (grid[x][col] === num) return false;
            }
            
            // Check 3x3 box
            const startRow = row - row % 3;
            const startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] === num) return false;
                }
            }
            
            return true;
        }

        function findEmptyCell(grid) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (grid[r][c] === 0) return [r, c];
                }
            }
            return null;
        }

        async function solveBacktracking(grid, visualize = true) {
            if (!solving) return false;
            
            const empty = findEmptyCell(grid);
            if (!empty) return true; // Solved!
            
            const [row, col] = empty;
            
            if (visualize) {
                const cell = document.getElementById(`cell-${row}-${col}`);
                cell.classList.add('solving');
                await sleep(speed);
            }
            
            for (let num = 1; num <= 9; num++) {
                if (!solving) return false;
                
                if (isValid(grid, row, col, num)) {
                    grid[row][col] = num;
                    steps++;
                    updateStats();
                    
                    if (visualize) {
                        const cell = document.getElementById(`cell-${row}-${col}`);
                        const input = cell.querySelector('input');
                        input.value = num;
                        await sleep(speed);
                    }
                    
                    if (await solveBacktracking(grid, visualize)) {
                        if (visualize) {
                            const cell = document.getElementById(`cell-${row}-${col}`);
                            cell.classList.remove('solving');
                            cell.classList.add('solved');
                        }
                        return true;
                    }
                    
                    // Backtrack
                    grid[row][col] = 0;
                    backtracks++;
                    updateStats();
                    
                    if (visualize) {
                        const cell = document.getElementById(`cell-${row}-${col}`);
                        cell.classList.remove('solving');
                        cell.classList.add('backtrack');
                        const input = cell.querySelector('input');
                        input.value = '';
                        await sleep(speed);
                        cell.classList.remove('backtrack');
                    }
                }
            }
            
            return false;
        }

        async function solveSudoku() {
            if (solving) return;
            
            solving = true;
            startTime = Date.now();
            resetStats();
            clearVisualEffects();
            document.getElementById('solve-btn').disabled = true;
            document.getElementById('status').textContent = 'Solving...';
            
            const success = await solveBacktracking(grid, true);
            
            solving = false;
            document.getElementById('solve-btn').disabled = false;
            document.getElementById('status').textContent = success ? 'Solved!' : 'No solution found';
            
            if (success) {
                // Mark all cells as solved
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        const cell = document.getElementById(`cell-${r}-${c}`);
                        cell.classList.add('solved');
                    }
                }
            }
        }

        function solveInstant() {
            resetStats();
            startTime = Date.now();
            
            const gridCopy = grid.map(row => [...row]);
            const success = solveBacktrackingInstant(gridCopy);
            
            if (success) {
                grid = gridCopy;
                displayGrid();
                document.getElementById('status').textContent = 'Solved Instantly!';
                updateStats();
            } else {
                document.getElementById('status').textContent = 'No solution found';
            }
        }

        function solveBacktrackingInstant(grid) {
            const empty = findEmptyCell(grid);
            if (!empty) return true;
            
            const [row, col] = empty;
            
            for (let num = 1; num <= 9; num++) {
                if (isValid(grid, row, col, num)) {
                    grid[row][col] = num;
                    steps++;
                    
                    if (solveBacktrackingInstant(grid)) {
                        return true;
                    }
                    
                    grid[row][col] = 0;
                    backtracks++;
                }
            }
            
            return false;
        }

        function stopSolving() {
            solving = false;
        }

        function updateSpeed(value) {
            speed = parseInt(value);
            document.getElementById('speed-value').textContent = value + 'ms';
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function resetStats() {
            steps = 0;
            backtracks = 0;
            updateStats();
        }

        function updateStats() {
            document.getElementById('steps').textContent = steps;
            document.getElementById('backtracks').textContent = backtracks;
            const elapsed = Date.now() - startTime;
            document.getElementById('time').textContent = elapsed + 'ms';
        }

        // Initialize the grid on page load
        initGrid();
        loadEasyPuzzle();
    </script>
</body>
</html>
